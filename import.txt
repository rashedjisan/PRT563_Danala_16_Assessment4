// ========================================
// CLEAR DATA
// ========================================
MATCH (n) DETACH DELETE n;

// ========================================
// CREATE CONSTRAINTS
// ========================================
CREATE CONSTRAINT patient_id IF NOT EXISTS 
FOR (p:Patient) REQUIRE p.patientID IS UNIQUE;

CREATE CONSTRAINT provider_id IF NOT EXISTS 
FOR (hp:HealthcareProvider) REQUIRE hp.providerID IS UNIQUE;

CREATE CONSTRAINT appointment_id IF NOT EXISTS 
FOR (a:Appointment) REQUIRE a.appointmentID IS UNIQUE;

CREATE CONSTRAINT record_id IF NOT EXISTS 
FOR (mr:MedicalRecord) REQUIRE mr.recordID IS UNIQUE;

CREATE CONSTRAINT prescription_id IF NOT EXISTS 
FOR (pr:Prescription) REQUIRE pr.prescriptionID IS UNIQUE;

CREATE CONSTRAINT medication_id IF NOT EXISTS 
FOR (m:Medication) REQUIRE m.medicationID IS UNIQUE;

CREATE CONSTRAINT facility_id IF NOT EXISTS 
FOR (f:Facility) REQUIRE f.facilityID IS UNIQUE;

CREATE CONSTRAINT department_id IF NOT EXISTS 
FOR (d:Department) REQUIRE d.departmentID IS UNIQUE;

CREATE CONSTRAINT service_id IF NOT EXISTS 
FOR (ss:SocialService) REQUIRE ss.serviceID IS UNIQUE;

// ========================================
// LOAD PATIENTS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///Patient.csv' AS row
CREATE (p:Patient {
    patientID: toInteger(row.PatientID),
    firstName: row.FirstName,
    lastName: row.LastName,
    dateOfBirth: date(row.DateOfBirth),
    gender: row.Gender,
    address: row.Address,
    phone: row.Phone,
    email: row.Email,
    bloodType: row.BloodType,
    medicareNumber: row.MedicareNumber,
    emergencyContact: row.EmergencyContact
});

// ========================================
// LOAD HEALTHCARE PROVIDERS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///HealthcareProvider.csv' AS row
CREATE (hp:HealthcareProvider {
    providerID: toInteger(row.ProviderID),
    firstName: row.FirstName,
    lastName: row.LastName,
    licenseNumber: row.LicenseNumber,
    specialization: row.Specialization,
    phone: row.Phone,
    email: row.Email,
    yearsOfExperience: toInteger(row.YearsOfExperience),
    providerType: row.ProviderType
});

// ========================================
// LOAD FACILITIES
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///Facility.csv' AS row
CREATE (f:Facility {
    facilityID: toInteger(row.FacilityID),
    facilityName: row.FacilityName,
    facilityType: row.FacilityType,
    address: row.Address,
    phone: row.Phone,
    capacity: toInteger(row.Capacity),
    operatingHours: row.OperatingHours
});

// ========================================
// LOAD DEPARTMENTS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///Department.csv' AS row
CREATE (d:Department {
    departmentID: toInteger(row.DepartmentID),
    departmentName: row.DepartmentName,
    floor: row.Floor,
    extension: row.Extension
});

// ========================================
// LOAD MEDICATIONS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///Medication.csv' AS row
CREATE (m:Medication {
    medicationID: toInteger(row.MedicationID),
    medicationName: row.MedicationName,
    genericName: row.GenericName,
    category: row.Category,
    sideEffects: row.SideEffects
});

// ========================================
// LOAD SOCIAL SERVICES
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///SocialService.csv' AS row
CREATE (ss:SocialService {
    serviceID: toInteger(row.ServiceID),
    serviceName: row.ServiceName,
    serviceType: row.ServiceType,
    description: row.Description,
    eligibilityCriteria: row.EligibilityCriteria
});

// ========================================
// LOAD APPOINTMENTS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///Appointment.csv' AS row
CREATE (a:Appointment {
    appointmentID: toInteger(row.AppointmentID),
    appointmentDate: date(row.AppointmentDate),
    appointmentTime: time(row.AppointmentTime),
    appointmentType: row.AppointmentType,
    status: row.Status,
    notes: row.Notes
});

// ========================================
// LOAD MEDICAL RECORDS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///MedicalRecord.csv' AS row
CREATE (mr:MedicalRecord {
    recordID: toInteger(row.RecordID),
    recordDate: date(row.RecordDate),
    chiefComplaint: row.ChiefComplaint,
    diagnosis: row.Diagnosis,
    treatmentPlan: row.TreatmentPlan,
    followUpRequired: CASE row.FollowUpRequired 
        WHEN 'true' THEN true 
        WHEN '1' THEN true 
        ELSE false 
    END
});

// ========================================
// LOAD PRESCRIPTIONS
// ========================================
LOAD CSV WITH HEADERS FROM 'file:///Prescription.csv' AS row
CREATE (pr:Prescription {
    prescriptionID: toInteger(row.PrescriptionID),
    dosage: row.Dosage,
    frequency: row.Frequency,
    duration: row.Duration,
    instructions: row.Instructions
});

// ========================================
// CREATE RELATIONSHIPS
// ========================================

// Patient -> MedicalRecord
LOAD CSV WITH HEADERS FROM 'file:///MedicalRecord.csv' AS row
MATCH (p:Patient {patientID: toInteger(row.PatientID)})
MATCH (mr:MedicalRecord {recordID: toInteger(row.RecordID)})
CREATE (p)-[:HAS_RECORD]->(mr);

// Patient -> Appointment
LOAD CSV WITH HEADERS FROM 'file:///Appointment.csv' AS row
MATCH (p:Patient {patientID: toInteger(row.PatientID)})
MATCH (a:Appointment {appointmentID: toInteger(row.AppointmentID)})
CREATE (p)-[:SCHEDULED]->(a);

// HealthcareProvider -> Appointment
LOAD CSV WITH HEADERS FROM 'file:///Appointment.csv' AS row
MATCH (hp:HealthcareProvider {providerID: toInteger(row.ProviderID)})
MATCH (a:Appointment {appointmentID: toInteger(row.AppointmentID)})
CREATE (hp)-[:ATTENDS]->(a);

// Appointment -> Facility
LOAD CSV WITH HEADERS FROM 'file:///Appointment.csv' AS row
MATCH (a:Appointment {appointmentID: toInteger(row.AppointmentID)})
MATCH (f:Facility {facilityID: toInteger(row.FacilityID)})
CREATE (a)-[:OCCURS_AT]->(f);

// MedicalRecord -> HealthcareProvider
LOAD CSV WITH HEADERS FROM 'file:///MedicalRecord.csv' AS row
MATCH (mr:MedicalRecord {recordID: toInteger(row.RecordID)})
MATCH (hp:HealthcareProvider {providerID: toInteger(row.ProviderID)})
CREATE (mr)-[:CREATED_BY]->(hp);

// MedicalRecord -> Prescription
LOAD CSV WITH HEADERS FROM 'file:///Prescription.csv' AS row
MATCH (mr:MedicalRecord {recordID: toInteger(row.RecordID)})
MATCH (pr:Prescription {prescriptionID: toInteger(row.PrescriptionID)})
CREATE (mr)-[:CONTAINS]->(pr);

// Prescription -> Medication
LOAD CSV WITH HEADERS FROM 'file:///Prescription.csv' AS row
MATCH (pr:Prescription {prescriptionID: toInteger(row.PrescriptionID)})
MATCH (m:Medication {medicationID: toInteger(row.MedicationID)})
CREATE (pr)-[:PRESCRIBES]->(m);

// Department -> Facility
LOAD CSV WITH HEADERS FROM 'file:///Department.csv' AS row
MATCH (d:Department {departmentID: toInteger(row.DepartmentID)})
MATCH (f:Facility {facilityID: toInteger(row.FacilityID)})
CREATE (d)-[:LOCATED_IN]->(f);

// HealthcareProvider -> Department
LOAD CSV WITH HEADERS FROM 'file:///ProviderDepartment.csv' AS row
MATCH (hp:HealthcareProvider {providerID: toInteger(row.ProviderID)})
MATCH (d:Department {departmentID: toInteger(row.DepartmentID)})
CREATE (hp)-[:WORKS_IN {
    startDate: date(row.StartDate)
}]->(d);

// Patient -> SocialService
LOAD CSV WITH HEADERS FROM 'file:///PatientService.csv' AS row
MATCH (p:Patient {patientID: toInteger(row.PatientID)})
MATCH (ss:SocialService {serviceID: toInteger(row.ServiceID)})
CREATE (p)-[:RECEIVES_SERVICE {
    startDate: date(row.StartDate),
    status: row.Status
}]->(ss);

// ========================================
// VERIFICATION
// ========================================
MATCH (n) 
RETURN labels(n)[0] AS NodeType, count(n) AS Count 
ORDER BY Count DESC;